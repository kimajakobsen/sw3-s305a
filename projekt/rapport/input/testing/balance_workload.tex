\chapter{Balance Workload Test}
\label{sec:balWorUniTes}
\myTop{The test cases made for the \me{BalanceWorkload} method of the \cl{Department} class are described in this chapter.
Code snippets are shown along with the description to make the test cases easier to understand.}
%To test our balance workload method we have chosen to use a white unit test.
%An analysis was made in order to make sure that every code path of the method was covered.
\fixme{Der skal stå noget i starten om hvilken metode der er brugt til at give disse test cases liv.}

The department class has a method called balance workload, which balances the workload between all staff members in the department. 
The method is described fully in section \ref{sec:balanceworkload}. 
To arrange the test a department object is initialized and the required properties are set. This means the \vari{Persons} property is set to a list of \cl{Persons} and each person is assigned a number of problem with tags. 
The arrange of a test case can be seen in code snippet \ref{lst:balanceWorkloadTest2arrange}. 
%\begin{comment}

\begin{lstlisting}[style=sourceCode, caption=\myCaption{The arrange phase of the unit test of balance workload}, label=lst:balanceWorkloadTest2arrange,name=src:balance]
var tag1 =  new Tag(){ TimeConsumed = 20, SolvedProblems = 1 , Priority = 1  };  
var tag2 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 2  }; 
var tag3 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 3  }; 
var tag4 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 4  }; 

var prob1 = new Problem() { Tags = new EntityCollection<Tag> { tag1 }, Reassignable = true };
var prob2 = new Problem() { Tags = new EntityCollection<Tag> { tag2 }, Reassignable = true };
var prob3 = new Problem() { Tags = new EntityCollection<Tag> { tag3 }, Reassignable = true };
var prob4 = new Problem() { Tags = new EntityCollection<Tag> { tag4 }, Reassignable = true };
   
var mike = new Person() { Name="mike", Worklist = new EntityCollection<Problem>() { prob1, prob2, prob3 } }; // Workload = 40
var john = new Person() { Name= "John", Worklist = new EntityCollection<Problem>() { prob4 } };               // = 10

Department target = new Department()
{
    Persons = new EntityCollection<Person>()
    {
        mike, john
    }
};
\end{lstlisting}
%\end{comment}

Now the expected result needs to be calculated. 
Mike has three problems and this gives him a total workload of $20 + 10 + 10 = 40$. The workload is calculated by \vari{TimeConsumed} divided by \vari{SolvedProblems} of each tag.
This gives the estimated time consumption of the problem. Add up all problems and the workload is calculated.

John has 1 problem which gives him a total workload of $10$. 
This implies that Mike's workload is overbalanced. 
The algorithm is expected to reassign the problems so the workload is balanced. 
Since there are four problems three with a estimated time consumption of 10 and one with 20.
The most balanced possible with the given problems is when one has 30($10 + 20$) workload and the other has 20($10 + 10$). 

This can be expressed with a boolean expression which can be tested with the assert method \me{IsTrue}. 
This assert can be seen on code snippet \ref{lst:balanceWorkloadTestAssert}.

%\begin{comment}
\begin{lstlisting}[style=sourceCode, caption=\myCaption{An example unit test which tests a specific instance of the balanceWorkload method.}, label=lst:balanceWorkloadTestAssert,name=src:balance]
target.BalanceWorkload();
Assert.IsTrue(
		(john.Worklist.Contains(john.Workload == 30 && mike.Workload == 20) ||
		(mike.Workload == 30 && john.Workload == 20)
	));
.
.
.
\end{lstlisting}
%\end{comment}

It is necessary to test various scenarios e.g. test cases where problems are solved, not reassignable, problems with extreme estimated time consumption, staff members with no problems, an empty department, various estimate time consumptions, and different priorities. 

\section{Dependency Injection}
\label{sec:independencyInjection}
For some methods dependency injection must be made in order to execute a proper test. 
In the example with \me{BalanceWorkload}, dependency injection could have been made on the workload property of \cl{person}. 
This was not made because the workload method were already tested at the time \me{BalanceWorkload} were tested.

To properly make a dependency injection the method in action should be programmed to an interface. 
This makes it easy to swap the implemented class with another class. 
We did this to test the method \me{GetStaff} in the \cl{ProblemDistributer} class. 
The method is described in section \ref{sec:dispro}.

\me{GetStaff} were designed to be more testable and therefore it acts on the \cl{IPerson} interface. 
The method depends on the \vari{Workload} property of \cl{person} and at the time of the unit test for this method the \vari{workload} were not fully implemented and neither were the \vari{isStaff} property. 
Therefore we made a \cl{TestPerson} class which implemented the \cl{IPerson} interface.
The \cl{TestStaff} implementation of the \me{isStaff} method returns true unless the \vari{name} is ``john''. 
The \me{workload} property just counts the number of items in the \cl{person} class's \vari{worklist}. 

In this way it is possible to make a unit test work.

\section{Regression Testing}
\label{sec:regression_balance_workload}
Like for the problem search, regression tests are used every time a significant change is made to balance workload method.
This is to ensure that the new change does not ruin anything that already worked.
The regression tests are simply all the unit tests of this method, which can be run every time a change is made to the method if necessary.
\fixme{Evt. alt source code i et appendix? Så kan vi henvise til det.}
\myTail{This chapter shows how the test cases of the \me{BalanceWorkload} method is made.
Exmaples from the test cases source code are given in this chapter to give a better understanding of the test cases.}