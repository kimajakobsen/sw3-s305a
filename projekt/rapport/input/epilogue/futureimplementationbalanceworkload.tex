\section{BalanceWorkload}
\label{sec:futureimplementationbalanceworkload}

The original \me{BalanceWorkload} method distributes the problems by looking at the staff member which has the highest workload as well as the one with the lowest, and then shifts the reassignable problems until the workload between the two are as equal as possible. This approach doesn't take the priority or whether or not the deadline is approved into account. 

The main idea behind the \me{FutureImplementationBalanceWorkload} method -- which is seen in code snippet \ref{lst:futureimplementationbalanceworkload} -- is that the algorithm only has to balance the workload by some extension, which is by always choosing the person with the minimum workload, whenever a problem is about to be distributed. The argument behind this idea is that whenever a staff member solves a problem, then the algorithm will be executed again, which then autimatically will assign him/her new problems.

This simple approach of distributing problems allows us to choose which problems to distribute first. From here, all we have to do is to sort the list of problems to distribute in the manner we want. In the \me{FutureImplementationBalanceWorkload} method, we've chosen to have the problems with an approved deadline at the top of a list, sorted by ascending priority

\begin{lstlisting}[style=sourceCode, caption=\myCaption{A possible future implementation of the \me{BalanceWorkload} algorithm.}, label=lst:futureimplementationbalanceworkload]
public void FutureImplementationBalanceWorkload()
{
    Person dummyPerson = new Person();
    List<Person> staffMembers = Persons.ToList();
    List<Problem> problemList = new List<Problem>();

    foreach (var member in staffMembers)
    {
        foreach (var problem in member.Worklist)
        {
            problemList.Add(problem);
        }
    }

    problemList = problemList.Where(x => x.Reassignable == true && x.SolvedAtTime == null).ToList();

    foreach (var problem in problemList)
    {
        problem.AssignedTo = dummyPerson;
    }

    while (problemList.Count > 0)
    {
        // find the person with the lowest workload
        Person min = Persons.FirstOrDefault(y => y.GetWorkload() == Persons.Min(x => x.GetWorkload()));

        // assign the most important problem to the person
        problemList[0].AssignedTo = min;
        problemList.RemoveAt(0);
    }
}
\end{lstlisting}
