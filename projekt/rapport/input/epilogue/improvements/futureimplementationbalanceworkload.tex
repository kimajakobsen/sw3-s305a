\section{BalanceWorkload}
\label{sec:futureimplementationbalanceworkload}

The original \me{BalanceWorkload} method distributes the problems by looking at the staff member which has the highest workload as well as the one with the lowest, and then shifts the reassignable problems until the workload between the two are as equal as possible. This approach does not take the priority nor the deadline into account. Section \ref{sec:balanceworkload} describe the \me{BalanceWorkload} method throughly. 

We deem that to be a significant problem, which is why we have suggested an alternative way to implement this feature, we call this \me{FutureImplementationBalanceWorkload}. This is shown in the code snippet: \ref{lst:futureimplementationbalanceworkload}. 

The main idea behind \me{FutureImplementationBalanceWorkload} is that the algorithm only has to balance the workload by some extent as a problem would always be added to the person with the lowest workload, every time there is an alteration of a problem the algorithm will then run again to distribute to workload properly.

This simple approach of distributing problems allows us to choose which problems to distribute first. All we have to do then is sort the list of problems to distribute them in the manner we want. In the \me{FutureImplementationBalanceWorkload} method, we have chosen to have the problems with an approved deadline at the top of a temporary list, sorted by highest priority at top. Below that all problems without a deadline.

In short, the \me{FutureImplementationBalanceWorkload} method does the above explained by first unassigning all the reassignable problems from all members of the specific department, followed by sorting them in the fashion explained above, and at last assigns the problems from the top of the temporary list, until the temporary list is empty.

\paragraph{Pros} are that problems which are more important will be solved faster.
\paragraph{Cons} are that the workload will be a slightly bit more unbalanced between the individual staff members in the department.
\paragraph{We did not implement this feature because} we decided early in the beginning only to focus on workload and not priority or deadlines. We discovered too late that this was not a hard issue, however we decided not to implement it as we felt that we did not have the time.

\begin{lstlisting}[style=sourceCode, caption=\myCaption{A possible future implementation of the \me{BalanceWorkload} algorithm.}, label=lst:futureimplementationbalanceworkload]
public void FutureImplementationBalanceWorkload()
{
    Person dummyPerson = new Person();
    List<Person> staffMembers = Persons.ToList();
    List<Problem> problemList = new List<Problem>();

    foreach (var member in staffMembers)
    {
        foreach (var problem in member.Worklist)
        {
            problemList.Add(problem);
        }
    }

    problemList = problemList.Where(x => x.Reassignable == true && x.SolvedAtTime == null).ToList();

    foreach (var problem in problemList)
    {
        problem.AssignedTo = dummyPerson;
    }

    while (problemList.Count > 0)
    {
        // find the person with the lowest workload
        Person min = Persons.FirstOrDefault(y => y.GetWorkload() == Persons.Min(x => x.GetWorkload()));

        // assign the most important problem to the person
        problemList[0].AssignedTo = min;
        problemList.RemoveAt(0);
    }
}
\end{lstlisting}


