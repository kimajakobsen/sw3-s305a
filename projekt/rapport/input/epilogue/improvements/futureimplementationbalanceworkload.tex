\section{BalanceWorkload}
\label{sec:futureimplementationbalanceworkload}

The original \me{BalanceWorkload} method distributes the problems by looking at the staff member which has the highest workload as well as the one with the lowest, and then shifts the reassignable problems until the workload between the two are as equal as possible. This approach doesn't take the priority or whether or not the deadline is approved into account. 

The main idea behind the \me{FutureImplementationBalanceWorkload} method -- which is seen in code snippet \ref{lst:futureimplementationbalanceworkload} -- is that the algorithm only has to balance the workload by some extension, which is by always choosing the person with the minimum workload, whenever a problem is about to be distributed. The argument behind this idea is that whenever a staff member solves a problem, then the algorithm will be executed again, which then autimatically will assign him/her new problems.

This simple approach of distributing problems allows us to choose which problems to distribute first. From here, all we have to do is to sort the list of problems to distribute in the manner we want. In the \me{FutureImplementationBalanceWorkload} method, we have chosen to have the problems with an approved deadline at the top of a temporary list, sorted by highest priority at top. Below that, all other problems -- problems without an approved deadline.

In short, the \me{FutureImplementationBalanceWorkload} method does the above explained by first unassigning all the reassignable problems from all members of the specific department, followed by sorting them in the fashion explained above, and at last continually assigns the problem from the top of the temporary list, until the temporary list is empty.

\begin{lstlisting}[style=sourceCode, caption=\myCaption{A possible future implementation of the \me{BalanceWorkload} algorithm.}, label=lst:futureimplementationbalanceworkload]
public void FutureImplementationBalanceWorkload()
{
    Person dummyPerson = new Person();
    List<Person> staffMembers = Persons.ToList();
    List<Problem> problemList = new List<Problem>();

    foreach (var member in staffMembers)
    {
        foreach (var problem in member.Worklist)
        {
            problemList.Add(problem);
        }
    }

    problemList = problemList.Where(x => x.Reassignable == true && x.SolvedAtTime == null).ToList();

    foreach (var problem in problemList)
    {
        problem.AssignedTo = dummyPerson;
    }

    while (problemList.Count > 0)
    {
        // find the person with the lowest workload
        Person min = Persons.FirstOrDefault(y => y.GetWorkload() == Persons.Min(x => x.GetWorkload()));

        // assign the most important problem to the person
        problemList[0].AssignedTo = min;
        problemList.RemoveAt(0);
    }
}
\end{lstlisting}
