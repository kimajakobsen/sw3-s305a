\chapter{Balance Workload Test}
\label{sec:balWorUniTes}
To test our balance workload method we have chosen to use a white unit test.
An analysis was made in order to make sure that every code path of the method was covered.

The department class has a method called balance workload, which balances the workload between all staff members in the department. 
The method is described fully in section \ref{sec:balanceworkload}. 
To arrange the test a department object is initialized and the required properties are set. This means the \vari{Persons} property is set to a list of \cl{Persons} and each person is assigned a number of problem with tags. 
The arrange can be seen in code snippet \ref{lst:balanceWorkloadTest2arrange}. 
%\begin{comment}

\begin{lstlisting}[style=sourceCode, caption=\myCaption{The arrange phase of the unit test of balance workload}, label=lst:balanceWorkloadTest2arrange]
var tag1 =  new Tag(){ TimeConsumed = 20, SolvedProblems = 1 , Priority = 1  };  
var tag2 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 2  }; 
var tag3 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 3  }; 
var tag4 =  new Tag(){ TimeConsumed = 10, SolvedProblems = 1 , Priority = 4  }; 

var prob1 = new Problem() { Tags = new EntityCollection<Tag> { tag1 }, Reassignable = true };
var prob2 = new Problem() { Tags = new EntityCollection<Tag> { tag2 }, Reassignable = true };
var prob3 = new Problem() { Tags = new EntityCollection<Tag> { tag3 }, Reassignable = true };
var prob4 = new Problem() { Tags = new EntityCollection<Tag> { tag4 }, Reassignable = true };
   
var mike = new Person() { Name="mike", Worklist = new EntityCollection<Problem>() { prob1, prob2, prob3 } }; // Workload = 40
var john = new Person() { Name= "John", Worklist = new EntityCollection<Problem>() { prob4 } };               // = 10

Department target = new Department()
{
    Persons = new EntityCollection<Person>()
    {
        mike, john
    }
};
\end{lstlisting}
%\end{comment}

Now the expected result needs to be calculated. 
Mike has three problems and this gives him a total workload of $20/1 + 20/2 + 20/2 = 40$.\fixme{forklar udregning, hvor kommer den fra} 
John has 1 problem which gives him a total workload of $20 / 2 = 10$. 
This implies that Mike's workload is overbalanced. 
The algorithm is expected to reassign the problems so the workload is balanced. 
The most balanced possible with the given problems is when one has 30($10 + 20$) workload and the other has 20($10 + 10$). \fixme{Jeg forst\aa r ikke disse tal. -Magnus}
This can be expressed with a boolean expression which can be tested with the assert method \me{IsTrue}. 
This assert can be seen on code snippet \ref{lst:balanceWorkloadTestAssert}.

%\begin{comment}
\begin{lstlisting}[style=sourceCode, caption=\myCaption{An example unit test which tests a specific instance of the balanceWorkload method.}, label=lst:balanceWorkloadTestAssert]
.
.
.
target.BalanceWorkload();
Assert.IsTrue(
		(john.Worklist.Contains(john.Workload == 30 && mike.Workload == 20) || 
		(mike.Workload == 30 && john.Workload == 20)
	));
.
.
.
\end{lstlisting}
%\end{comment}

It is necessary to test various scenarios e.g. test cases where problems are solved, not reassignable, problems with extreme estimated time consumption, staff members with no problems, an empty department, various estimate time consumptions, and different priorities. 

\subsection{Dependency Injection}
\label{sec:independencyInjection}
For some methods dependency injection must be made in order to execute a proper test. 
In the example with \me{BalanceWorkload}, dependency injection could have been made on the workload property of \cl{person}. 
This was not made because the workload method were already tested at the time \me{BalanceWorkload} were tested.

To properly make a dependency injection the method in action should be programmed to an interface. 
This makes it easy to swap the implemented class with another class. 
We did this to test the method \me{GetStaff} in the \cl{ProblemDistributer} class. 
The method is described in section \ref{sec:dispro}.

\me{GetStaff} were designed to be more testable and therefore it acts on the \cl{IPerson} interface. 
The method depends on the \vari{Workload} property of \cl{person} and at the time of the unit test for this method the \vari{workload} were not fully implemented and neither were the \vari{isStaff} property. 
Therefore we made a \cl{TestPerson} class which implemented the \cl{IPerson} interface.
The \cl{TestStaff} implementation of the \me{isStaff} method returns true unless the \vari{name} is ``john''. 
The \me{workload} property just counts the number of items in the \cl{person} class's \vari{worklist}. 

In this way it is possible to make a unit test work. 