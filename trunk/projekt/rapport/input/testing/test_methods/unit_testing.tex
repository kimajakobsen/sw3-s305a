\section{Unit Testing}
\label{chap:testing}
Throughout the development we have used the Team Test Feature within Visual Studios, which is an integrated unit-testing framework. \cite{teamtest}
The idea behind unit testing is to check an individual method by executing it with appropriate input, and afterwards check that its output corresponds to the expected.

Generally a unit test is classified as a white box test because it should cover each code path in order to make sure that the test actually suffice to test the given unit. \cite[p.~39]{williams06}, thus it requires knowledge of the code to create such a test.
To make sure that each code path is covered, the method for code coverage described in subsection \ref{sub:codeCoverage} is used.

All major functions have been tested with Team Test. This means that we have not made any unit testing on controllers. 
Throughout the development, we have omitted to write complex methods and functions in the controllers, and instead written them in the model or our tool component. We have therefore deemed it unnecessary to unit test each controller. Instead we have tested them manually by running the program and seen that it behaves as expected, in effect running black box tests of our controllers.

We have run tests for the search and the problem distribution methods, these are described in chapter \ref{chap:problem_search_test} and \ref{sec:balWorUniTes} respectively, along with other parts of the tool component and the model.

To better explain a unit test we divided it in three parts: an arrange phase, an act phase, and an assert phase. 
The arrange phase sets up the input and requirements for the test. 
The act is the run of the method and the assert is the actual testing, e.g. where the result from the method is compared to an expected value. 

In chapter \ref{sec:balWorUniTes} a white box unit test of the balance workload method is presented and in section \ref{sec:independencyInjection} a unit test with dependency injection is explained.