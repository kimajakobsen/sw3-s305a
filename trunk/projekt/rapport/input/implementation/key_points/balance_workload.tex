\section{Balance Workload}
Whenever a staff is removed from a department or has finished solving a problem. 
It is necessary to balance the workload of each staff in the department, since we do not want the staffs to be overloaded with problems. 

To balance the workload, each staffs workload must be calculated. 
The workload of a staff is defined by the amount of time estimated that each problem on his workload takes to be solved. The workload is calculated by the \me{GetWorkload} method.

The time a problem takes to be solved is estimated by the average time consumption of the tags connected to the problem. This is calculated by the \me{CalculateTimeConsumption} method.

The \me{BalanceWorkload} method works by finding the staff in the department with the minimum workload and the staff with the maximum workload. Then it moves the highest priority problems from the maximum staff to the minimum. It keeps reassigning problems until the minimum staff has a higher or equal workload than the maximum staff. If it is higher the problem is reassigned back. All this is iterated the number of staffs times. 

\begin{lstlisting}[style=sourceCode, caption=\myCaption{To be}]
 public void BalanceWorkload()
        {
            // Run through all persons.
            for (var i = 0; i < Persons.Count; i++)
            {
                    // Find the person with the highest workload
                    var max = Persons.FirstOrDefault(y => y.GetWorkload() == Persons.Max(x => x.GetWorkload()));

                    // If there is no person, do nothing.
                    if (max.Worklist == null) return;
                    
                    // Sort his worklist so that the highest priority is the first.
                    max.Worklist.ToList().Sort(Problem.GetComparer());

                    // Find the person with the lowest workload
                    var min = Persons.FirstOrDefault(y => y.GetWorkload() == Persons.Min(x => x.GetWorkload()));
                 
                    // If max and min is the same person.
                    if (max == min)  return;

                    // To determine the while loop.
                    bool couldStillMove = true;
                    do
                    {
                        // Finde the reassignable problem with the highest priority which has not been moved yet. 
                        var problemToBeMoved = max.Worklist.FirstOrDefault(y => y.Reassignable == true && 
																		   		y.HasBeen == false && 
																				y.SolvedAtTime == null);
                   
  						// If none can be moved leave the while loop
                        if (problemToBeMoved == null)
                        {
                            couldStillMove = false;
                        }
                        else
                        {
                            // Mark as has been moved
                            problemToBeMoved.HasBeen = true;

                            // Reassign the highest priority problem to staff called min.
                            problemToBeMoved.AssignedTo = min;
                            if (min.Workload > max.Workload)
                            {
                                // Move it back
                                problemToBeMoved.AssignedTo = max;
                                couldStillMove = false;
                            }
                            else if (min.Workload == max.Workload)
                            {
                                // Don't move bakc if they are equal
                                couldStillMove = false;
                            }
                        }

                    } while (couldStillMove);
                }
            }
\end{lsilisting}

\subsection{eta}
\label{}


Get workload kalder ETA